# Terraform EC2 Deployment with Azure DevOps - Setup Guide

## Prerequisites

- Azure DevOps account and project
- AWS account with appropriate permissions
- AWS CLI configured locally
- Terraform installed locally (for testing)
- Git repository

## Project Structure

```
project-root/
├── terraform/
│   ├── main.tf
│   ├── variables.tf
│   ├── outputs.tf
│   ├── terraform.tfvars
│   └── user-data.sh
├── azure-pipelines.yml
└── README.md
```

## Step 1: Prepare AWS Resources

### 1.1 Create S3 Bucket for Terraform State

```bash
aws s3 mb s3://your-terraform-state-bucket --region us-east-1
aws s3api put-bucket-versioning \
  --bucket your-terraform-state-bucket \
  --versioning-configuration Status=Enabled
```

### 1.2 Create DynamoDB Table for State Locking

```bash
aws dynamodb create-table \
  --table-name terraform-state-lock \
  --attribute-definitions AttributeName=LockID,AttributeType=S \
  --key-schema AttributeName=LockID,KeyType=HASH \
  --billing-mode PAY_PER_REQUEST \
  --region us-east-1
```

### 1.3 Create IAM User for Azure DevOps

1. Go to AWS IAM Console
2. Create a new user: `azure-devops-terraform`
3. Attach policy: `AdministratorAccess` (or more restrictive custom policy)
4. Generate Access Key and Secret Key
5. **Save these credentials securely**

## Step 2: Configure Azure DevOps

### 2.1 Install Terraform Extension

1. Go to Azure DevOps Organization Settings
2. Navigate to Extensions → Browse Marketplace
3. Search for "Terraform" by Microsoft DevLabs
4. Install the extension

### 2.2 Create AWS Service Connection

1. Go to Project Settings → Service connections
2. Click "New service connection"
3. Select "AWS for Terraform"
4. Enter your AWS credentials:
   - **Connection name**: `AWS-Service-Connection`
   - **Access Key ID**: (from Step 1.3)
   - **Secret Access Key**: (from Step 1.3)
   - **Region**: `us-east-1`
5. Click "Verify and save"

### 2.3 Create Variable Group

1. Go to Pipelines → Library
2. Click "+ Variable group"
3. Name: `terraform-aws-credentials`
4. Add variables:
   - `AWS_REGION`: `us-east-1`
   - `TF_STATE_BUCKET`: `your-terraform-state-bucket`
   - `TF_STATE_KEY`: `ec2/terraform.tfstate`
5. Save the variable group
6. Grant pipeline access to this variable group

### 2.4 Create Environment for Approvals

1. Go to Pipelines → Environments
2. Click "New environment"
3. Name: `production`
4. Add approvers:
   - Click on "..." menu → Approvals and checks
   - Add "Approvals" check
   - Add required approvers
5. This ensures manual approval before applying changes

## Step 3: Prepare Your Repository

### 3.1 Create Repository Structure

```bash
mkdir -p terraform-ec2-project/terraform
cd terraform-ec2-project
```

### 3.2 Add Files

Place all the provided files in the appropriate locations:
- Terraform files in `terraform/` directory
- `azure-pipelines.yml` in root directory

### 3.3 Update Configuration

Edit `terraform/terraform.tfvars`:
```hcl
vpc_id    = "vpc-YOUR_VPC_ID"
subnet_id = "subnet-YOUR_SUBNET_ID"
key_name  = "your-existing-keypair"
```

Update `terraform/main.tf` backend configuration with your bucket name.

### 3.4 Initialize Git and Push

```bash
git init
git add .
git commit -m "Initial commit: Terraform EC2 with Azure DevOps"
git remote add origin <your-azure-repos-url>
git push -u origin main
```

## Step 4: Configure the Pipeline

### 4.1 Create New Pipeline

1. Go to Pipelines → Create Pipeline
2. Select "Azure Repos Git"
3. Select your repository
4. Choose "Existing Azure Pipelines YAML file"
5. Select `/azure-pipelines.yml`
6. Click "Continue"

### 4.2 Update Pipeline Variables

Before running, update the pipeline YAML:
- Replace `your-terraform-state-bucket` with your actual bucket name
- Ensure `AWS-Service-Connection` matches your service connection name
- Verify the `WORKING_DIR` path is correct

### 4.3 Run the Pipeline

1. Click "Run pipeline"
2. The pipeline will execute:
   - **Validate**: Check Terraform syntax
   - **Plan**: Generate execution plan
   - **Apply**: Wait for approval, then apply changes

## Step 5: Managing the Infrastructure

### Manual Testing Locally

```bash
cd terraform/

# Initialize
terraform init

# Validate
terraform validate

# Plan
terraform plan

# Apply
terraform apply

# Destroy
terraform destroy
```

### Pipeline Operations

**Deploy Changes:**
- Push to `main` branch → Triggers full pipeline with approval gate

**View Plan Only:**
- Push to `develop` branch → Runs validate and plan only

**Destroy Infrastructure:**
- Enable the Destroy stage in `azure-pipelines.yml` by setting `condition: true`
- Run the pipeline manually

## Step 6: Security Best Practices

1. **Restrict SSH Access**: Update `allowed_ssh_cidr` in tfvars to your IP only
2. **Use IAM Roles**: Consider using AWS IAM roles instead of access keys
3. **Secrets Management**: Store sensitive values in Azure Key Vault
4. **State File Security**: Enable S3 bucket encryption and restrict access
5. **Branch Protection**: Require pull requests and reviews for main branch
6. **Audit Logs**: Enable CloudTrail and Azure DevOps audit logs

## Troubleshooting

### Common Issues

**Issue: Terraform init fails**
- Verify S3 bucket exists and is accessible
- Check AWS service connection credentials
- Ensure DynamoDB table exists

**Issue: Permission denied**
- Verify IAM user has necessary permissions
- Check AWS service connection configuration

**Issue: Pipeline doesn't trigger**
- Check trigger paths in azure-pipelines.yml
- Verify branch policies

**Issue: State locked**
- Check DynamoDB table for stuck locks
- Manually remove lock if needed (with caution)

## Next Steps

1. **Add More Resources**: Extend Terraform to include load balancers, databases, etc.
2. **Multiple Environments**: Create dev, staging, prod workspaces
3. **Modules**: Organize code into reusable Terraform modules
4. **Testing**: Add tfsec, checkov for security scanning
5. **Notifications**: Configure pipeline notifications in Azure DevOps

## Useful Commands

```bash
# View Terraform state
terraform state list

# Show specific resource
terraform state show aws_instance.app_server

# Refresh state
terraform refresh

# Import existing resources
terraform import aws_instance.app_server i-1234567890abcdef0
```

## Resources

- [Terraform AWS Provider Documentation](https://registry.terraform.io/providers/hashicorp/aws/latest/docs)
- [Azure DevOps Terraform Tasks](https://marketplace.visualstudio.com/items?itemName=ms-devlabs.custom-terraform-tasks)
- [Terraform Best Practices](https://www.terraform-best-practices.com/)
